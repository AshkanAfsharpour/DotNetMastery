# Data Structures & Algorithms To-Do List

## 1. Arrays
- [ ] Implement basic operations: insert, delete, traverse.
- [ ] Multi-dimensional arrays.
- [ ] Dynamic arrays (List in C#).

## 2. Linked Lists
- [ ] Implement **Singly Linked List**.
  - [ ] Insert a node (beginning, middle, end).
  - [ ] Delete a node (beginning, middle, end).
  - [ ] Traverse and print elements.
- [ ] Implement **Doubly Linked List**.
- [ ] Implement **Circular Linked List**.

## 3. Stacks
- [ ] Implement stack using arrays.
- [ ] Implement stack using linked lists.
- [ ] Operations: push, pop, peek, isEmpty.
- [ ] Applications:
  - [ ] Reverse a string.
  - [ ] Check for balanced parentheses in an expression.

## 4. Queues
- [ ] Implement queue using arrays.
- [ ] Implement queue using linked lists.
- [ ] Operations: enqueue, dequeue, front, isEmpty.
- [ ] Implement **Circular Queue**.
- [ ] Implement **Priority Queue**.
- [ ] Implement **Deque** (Double-ended queue).

## 5. Trees
- [ ] Implement **Binary Tree**.
  - [ ] Pre-order, In-order, Post-order traversals (recursive and iterative).
  - [ ] Level-order traversal (Breadth-First Search).
- [ ] Implement **Binary Search Tree** (BST).
  - [ ] Insert a node.
  - [ ] Delete a node.
  - [ ] Find minimum, maximum.
  - [ ] Search for a value.
- [ ] Implement **Balanced Binary Search Tree (AVL Tree)**.
- [ ] Implement **Red-Black Tree**.
- [ ] Implement **Trie (Prefix Tree)**.
- [ ] Implement **Segment Tree** (with range queries).

## 6. Heaps
- [ ] Implement **Min-Heap** and **Max-Heap**.
- [ ] Operations: insert, delete, extract-min, extract-max.
- [ ] Implement **Heap Sort**.
- [ ] Priority queue implementation using heap.

## 7. Graphs
- [ ] Implement graph using adjacency matrix.
- [ ] Implement graph using adjacency list.
- [ ] Depth-First Search (DFS).
- [ ] Breadth-First Search (BFS).
- [ ] Detect cycle in a graph (both directed and undirected).
- [ ] Find connected components.
- [ ] Implement **Dijkstra’s algorithm** (shortest path).
- [ ] Implement **Kruskal's algorithm** (minimum spanning tree).
- [ ] Implement **Prim’s algorithm** (minimum spanning tree).
- [ ] Implement **Topological Sorting**.

## 8. Hashing
- [ ] Implement a hash table with separate chaining (using linked lists).
- [ ] Implement a hash table with open addressing (linear probing).
- [ ] Implement **Double Hashing**.

## 9. Searching Algorithms
- [ ] Linear Search.
- [ ] Binary Search (recursive and iterative).
- [ ] Interpolation Search.
- [ ] Ternary Search.

## 10. Sorting Algorithms
- [ ] Implement **Bubble Sort**.
- [ ] Implement **Selection Sort**.
- [ ] Implement **Insertion Sort**.
- [ ] Implement **Merge Sort**.
- [ ] Implement **Quick Sort**.
- [ ] Implement **Heap Sort**.
- [ ] Implement **Radix Sort**.
- [ ] Implement **Counting Sort**.
- [ ] Implement **Bucket Sort**.

## 11. Recursion
- [ ] Basic examples (factorial, Fibonacci sequence).
- [ ] Solving the Tower of Hanoi.
- [ ] Generate all permutations of a string.
- [ ] Subset sum problem.

## 12. Dynamic Programming (DP)
- [ ] Implement **Fibonacci sequence** (DP approach).
- [ ] Implement **Longest Common Subsequence**.
- [ ] Implement **Knapsack Problem**.
- [ ] Implement **Coin Change Problem**.
- [ ] Implement **Longest Increasing Subsequence**.
- [ ] Implement **Matrix Chain Multiplication**.

## 13. Greedy Algorithms
- [ ] Implement **Activity Selection Problem**.
- [ ] Implement **Fractional Knapsack Problem**.
- [ ] Implement **Huffman Encoding**.

## 14. Backtracking
- [ ] Solve the **N-Queens Problem**.
- [ ] Solve the **Rat in a Maze Problem**.
- [ ] Solve the **Sudoku Solver**.

## 15. Bit Manipulation
- [ ] Basic operations (AND, OR, XOR, NOT).
- [ ] Counting set bits in an integer.
- [ ] Checking if a number is a power of 2.
- [ ] Swapping two numbers without using a temporary variable.
- [ ] Finding the only non-repeating element in an array (XOR approach).

---

### Additional Tasks
- [ ] Write **unit tests** for each data structure and algorithm implementation.
- [ ] Create **README** files for each data structure and algorithm explaining the concept, operations, and use cases.
- [ ] Document **time complexity** and **space complexity** for each implementation.
- [ ] Provide real-world examples and applications for each data structure and algorithm (optional, but valuable for learners).
